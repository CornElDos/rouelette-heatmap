<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Roulette Heatmap App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .hidden {
      display: none;
    }
    .roulette-grid {
      display: grid;
      grid-gap: 5px;
      justify-content: center;
    }
    .roulette-button {
      width: 50px;
      height: 50px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      background-color: #f9f9f9;
    }
    .selected-numbers {
      margin: 10px 0;
    }
    table {
      border-collapse: collapse;
      margin: 10px auto;
    }
    td {
      border: 1px solid #000;
      width: 50px;
      height: 50px;
      text-align: center;
      vertical-align: middle;
      font-size: 16px;
    }
    .heatmap-cell {
      transition: background-color 0.3s;
    }
    #resetNumbers {
      margin-top: 10px;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
    }
    /* Gap display styles */
    #lineCounterDisplay, #columnCounterDisplay {
      margin-top: 15px;
    }
    /* Container for number grid and gaps (side by side) */
    #inputAndGapsContainer {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    /* Bet suggestion area */
    #betSuggestionArea {
      margin-top: 20px;
      border: 1px solid #000;
      padding: 10px;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
    }
    #betSuggestionArea h3 {
      margin-top: 0;
    }
    .form-row {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Roulette Heatmap App</h1>
  
  <!-- Step 1: Choose table type -->
  <div id="rouletteTypeSelection">
    <p>Choose table type:</p>
    <label>
      <input type="radio" name="tableType" value="european" checked> Single zero (European)
    </label>
    <label>
      <input type="radio" name="tableType" value="american"> 0/00 (American)
    </label>
    <button id="confirmType">Confirm</button>
  </div>

  <!-- Step 1b: Bankroll, stake style, rounding & progression selection -->
  <div id="bankrollSection" class="hidden">
    <div class="form-row">
      <label for="bankrollInput">Enter your bankroll:</label><br>
      <input type="number" id="bankrollInput" min="1" value="1000">
    </div>
    <div class="form-row">
      <label>Choose stake style:</label><br>
      <input type="radio" name="stakeStyle" value="fixed" checked> Fixed amount<br>
      <input type="radio" name="stakeStyle" value="percent"> Percentage of bankroll
    </div>
    <div class="form-row" id="baseBetRow">
      <label for="baseBetInput">Base bet (units):</label><br>
      <input type="number" id="baseBetInput" min="1" value="10">
    </div>
    <div class="form-row hidden" id="basePercentRow">
      <label for="basePercentInput">Base percentage (%):</label><br>
      <input type="number" id="basePercentInput" min="1" max="100" value="10">
    </div>
    <div class="form-row">
      <label>Round bet size to:</label><br>
      <input type="radio" name="rounding" value="5" checked> Nearest 5<br>
      <input type="radio" name="rounding" value="10"> Nearest 10
    </div>
    <div class="form-row">
      <label>Choose betting progression:</label><br>
      <input type="radio" name="betProgression" value="martingale" checked> Martingale<br>
      <input type="radio" name="betProgression" value="fibonacci"> Fibonacci<br>
      <input type="radio" name="betProgression" value="padovan"> Padovan
    </div>
    <button id="confirmBankroll">Confirm Bankroll & Settings</button>
  </div>

  <!-- Step 2: Enter the numbers that hit the table -->
  <div id="numberInputSection" class="hidden">
    <p>Click on the numbers that hit the roulette table:</p>
    <div id="inputAndGapsContainer">
      <div>
        <div id="numberGrid" class="roulette-grid"></div>
        <div class="selected-numbers">
          Selected numbers: <span id="selectedNumbersDisplay"></span>
        </div>
        <button id="resetNumbers">Reset</button>
      </div>
      <div>
        <div id="lineCounterDisplay"></div>
        <div id="columnCounterDisplay"></div>
      </div>
    </div>
  </div>

  <!-- Step 3: Choose which heatmap to display -->
  <div id="heatmapOptions" class="hidden">
    <p>Choose which heatmap you want to display:</p>
    <button id="showStandardHeatmap">Show standard roulette heatmap</button>
    <button id="showRacetrackHeatmap">Show racetrack heatmap</button>
  </div>

  <!-- Heatmap display area -->
  <div id="heatmapDisplay" class="hidden">
    <!-- The heatmap layout will be rendered here -->
  </div>

  <!-- Bet Suggestion Section -->
  <div id="betSuggestionArea" class="hidden">
    <h3>Bet Suggestion</h3>
    <p><strong>Bankroll:</strong> <span id="bankrollDisplay"></span></p>
    <p><strong>Suggested Bet:</strong> <span id="suggestedBetDisplay"></span></p>
    <p><strong>Bet Size:</strong> <span id="betSizeDisplay"></span></p>
    <p><strong>Win Probability:</strong> <span id="winProbabilityDisplay"></span></p>
    <p><strong>Last Bet Result:</strong> <span id="lastBetResultDisplay">N/A</span></p>
  </div>

  <script>
    // --- Global Variables ---
    let tableType = 'european';
    let selectedNumbers = [];
    const minSpinsForHeatmap = 5;
    let currentHeatmapLayout = null;

    // Bankroll and betting settings
    let bankroll = 1000;
    let stakeStyle = 'fixed';  // "fixed" or "percent"
    let baseBet = 10;
    let basePercent = 10;
    let roundingFactor = 5;  // 5 or 10
    let betProgression = 'martingale'; // "martingale", "fibonacci", or "padovan"

    // For tracking consecutive losses (for progression systems)
    let consecutiveLosses = 0;

    // Current bet suggestion
    let currentBet = {
      betType: null,     // "line" or "column"
      betTarget: null,   // e.g. "Line 3" or "Column 2"
      betSize: 0
    };

    // Define line groups
    const lineGroups = [
      { name: "Line 1", numbers: ["1", "2", "3", "4", "5", "6"] },
      { name: "Line 2", numbers: ["7", "8", "9", "10", "11", "12"] },
      { name: "Line 3", numbers: ["13", "14", "15", "16", "17", "18"] },
      { name: "Line 4", numbers: ["19", "20", "21", "22", "23", "24"] },
      { name: "Line 5", numbers: ["25", "26", "27", "28", "29", "30"] },
      { name: "Line 6", numbers: ["31", "32", "33", "34", "35", "36"] }
    ];

    // Define column groups
    const columnGroups = [
      { name: "Column 1", numbers: ["1","4","7","10","13","16","19","22","25","28","31","34"] },
      { name: "Column 2", numbers: ["2","5","8","11","14","17","20","23","26","29","32","35"] },
      { name: "Column 3", numbers: ["3","6","9","12","15","18","21","24","27","30","33","36"] }
    ];

    // Element references
    const rouletteTypeSelectionDiv = document.getElementById('rouletteTypeSelection');
    const bankrollSectionDiv = document.getElementById('bankrollSection');
    const numberInputSectionDiv = document.getElementById('numberInputSection');
    const heatmapOptionsDiv = document.getElementById('heatmapOptions');
    const heatmapDisplayDiv = document.getElementById('heatmapDisplay');
    const selectedNumbersDisplay = document.getElementById('selectedNumbersDisplay');
    const numberGridDiv = document.getElementById('numberGrid');
    const resetButton = document.getElementById('resetNumbers');

    const betSuggestionAreaDiv = document.getElementById('betSuggestionArea');
    const bankrollDisplay = document.getElementById('bankrollDisplay');
    const suggestedBetDisplay = document.getElementById('suggestedBetDisplay');
    const betSizeDisplay = document.getElementById('betSizeDisplay');
    const winProbabilityDisplay = document.getElementById('winProbabilityDisplay');
    const lastBetResultDisplay = document.getElementById('lastBetResultDisplay');

    // --- Event Handlers ---
    document.getElementById('confirmType').addEventListener('click', function() {
      const radios = document.getElementsByName('tableType');
      for (let radio of radios) {
        if (radio.checked) {
          tableType = radio.value;
          break;
        }
      }
      rouletteTypeSelectionDiv.classList.add('hidden');
      bankrollSectionDiv.classList.remove('hidden');
    });

    // Stake style change
    const stakeStyleRadios = document.getElementsByName('stakeStyle');
    stakeStyleRadios.forEach(radio => {
      radio.addEventListener('change', function() {
        stakeStyle = this.value;
        toggleBetInput();
      });
    });
    function toggleBetInput() {
      const baseBetRow = document.getElementById('baseBetRow');
      const basePercentRow = document.getElementById('basePercentRow');
      if (stakeStyle === 'fixed') {
        baseBetRow.classList.remove('hidden');
        basePercentRow.classList.add('hidden');
      } else {
        baseBetRow.classList.add('hidden');
        basePercentRow.classList.remove('hidden');
      }
    }

    // Read rounding and progression selections on bankroll confirmation
    document.getElementById('confirmBankroll').addEventListener('click', function() {
      bankroll = parseInt(document.getElementById('bankrollInput').value) || 1000;
      stakeStyle = [...stakeStyleRadios].find(r => r.checked).value;
      baseBet = parseInt(document.getElementById('baseBetInput').value) || 10;
      basePercent = parseInt(document.getElementById('basePercentInput').value) || 10;
      roundingFactor = parseInt([...document.getElementsByName('rounding')].find(r => r.checked).value);
      betProgression = [...document.getElementsByName('betProgression')].find(r => r.checked).value;

      bankrollSectionDiv.classList.add('hidden');
      setupNumberGrid();
      numberInputSectionDiv.classList.remove('hidden');
      updateLineCounters();
      updateColumnCounters();
      betSuggestionAreaDiv.classList.remove('hidden');
      updateBetSuggestion();
      displayBankroll();
    });

    function setupNumberGrid() {
      numberGridDiv.innerHTML = '';
      let numbers = [];
      if (tableType === 'european') {
        numbers.push('0');
        for (let i = 1; i <= 36; i++) {
          numbers.push(i.toString());
        }
      } else {
        numbers.push('0');
        numbers.push('00');
        for (let i = 1; i <= 36; i++) {
          numbers.push(i.toString());
        }
      }
      numbers.forEach(num => {
        let btn = document.createElement('button');
        btn.textContent = num;
        btn.className = 'roulette-button';
        btn.dataset.number = num;
        btn.dataset.count = 0;
        btn.addEventListener('click', function() {
          selectedNumbers.push(num);
          updateSelectedNumbersDisplay();
          let currentCount = parseInt(btn.dataset.count);
          currentCount++;
          btn.dataset.count = currentCount;
          btn.textContent = num + (currentCount > 0 ? ' (' + currentCount + ')' : '');
          if (selectedNumbers.length >= minSpinsForHeatmap) {
            heatmapOptionsDiv.classList.remove('hidden');
          }
          if (currentHeatmapLayout !== null) {
            displayHeatmap(currentHeatmapLayout);
          }
          updateLineCounters();
          updateColumnCounters();
          checkLastBetResult(num);
          updateBetSuggestion();
        });
        numberGridDiv.appendChild(btn);
      });
      numberGridDiv.style.gridTemplateColumns = 'repeat(6, 50px)';
    }

    function updateSelectedNumbersDisplay() {
      selectedNumbersDisplay.textContent = selectedNumbers.join(', ');
    }

    // --- Gap Counters ---
    function updateLineCounters() {
      let displayHTML = "<h3>Line Gaps</h3>";
      lineGroups.forEach(group => {
        let lastIndex = -1;
        for (let i = selectedNumbers.length - 1; i >= 0; i--) {
          if (group.numbers.includes(selectedNumbers[i])) {
            lastIndex = i;
            break;
          }
        }
        let gap = (lastIndex === -1) ? selectedNumbers.length : (selectedNumbers.length - lastIndex - 1);
        displayHTML += `<p>${group.name}: ${gap} spin(s) since win</p>`;
      });
      document.getElementById("lineCounterDisplay").innerHTML = displayHTML;
    }

    function updateColumnCounters() {
      let displayHTML = "<h3>Column Gaps</h3>";
      columnGroups.forEach(group => {
        let lastIndex = -1;
        for (let i = selectedNumbers.length - 1; i >= 0; i--) {
          if (group.numbers.includes(selectedNumbers[i])) {
            lastIndex = i;
            break;
          }
        }
        let gap = (lastIndex === -1) ? selectedNumbers.length : (selectedNumbers.length - lastIndex - 1);
        displayHTML += `<p>${group.name}: ${gap} spin(s) since win</p>`;
      });
      document.getElementById("columnCounterDisplay").innerHTML = displayHTML;
    }

    // --- Heatmap ---
    function getColorForCount(count) {
      if (count === 0) return '#fff';
      if (count === 1) return '#ffcccc';
      if (count === 2) return '#ff9999';
      if (count >= 3) return '#ff6666';
      return '#fff';
    }
    document.getElementById('showStandardHeatmap').addEventListener('click', function() {
      currentHeatmapLayout = 'standard';
      displayHeatmap('standard');
    });
    document.getElementById('showRacetrackHeatmap').addEventListener('click', function() {
      currentHeatmapLayout = 'racetrack';
      displayHeatmap('racetrack');
    });
    function getNumberFrequencies() {
      let frequencies = {};
      let possibleNumbers = [];
      if (tableType === 'european') {
        possibleNumbers.push('0');
        for (let i = 1; i <= 36; i++) {
          possibleNumbers.push(i.toString());
        }
      } else {
        possibleNumbers.push('0', '00');
        for (let i = 1; i <= 36; i++) {
          possibleNumbers.push(i.toString());
        }
      }
      possibleNumbers.forEach(num => frequencies[num] = 0);
      selectedNumbers.forEach(num => {
        if (frequencies[num] !== undefined) {
          frequencies[num]++;
        }
      });
      return frequencies;
    }
    function displayHeatmap(layoutType) {
      heatmapDisplayDiv.innerHTML = '';
      heatmapDisplayDiv.classList.remove('hidden');
      const frequencies = getNumberFrequencies();
      if (layoutType === 'standard') {
        let table = document.createElement('table');
        if (tableType === 'european') {
          let row0 = document.createElement('tr');
          let cell0 = document.createElement('td');
          cell0.colSpan = 3;
          cell0.textContent = '0';
          cell0.className = 'heatmap-cell';
          cell0.style.backgroundColor = getColorForCount(frequencies['0']);
          row0.appendChild(cell0);
          table.appendChild(row0);
          for (let i = 0; i < 12; i++) {
            let row = document.createElement('tr');
            for (let j = 0; j < 3; j++) {
              let num = (i * 3 + j + 1).toString();
              let cell = document.createElement('td');
              cell.textContent = num;
              cell.className = 'heatmap-cell';
              cell.style.backgroundColor = getColorForCount(frequencies[num]);
              row.appendChild(cell);
            }
            table.appendChild(row);
          }
        } else {
          let row0 = document.createElement('tr');
          let cell0 = document.createElement('td');
          cell0.textContent = '0';
          cell0.className = 'heatmap-cell';
          cell0.style.backgroundColor = getColorForCount(frequencies['0']);
          row0.appendChild(cell0);
          let cell00 = document.createElement('td');
          cell00.textContent = '00';
          cell00.className = 'heatmap-cell';
          cell00.style.backgroundColor = getColorForCount(frequencies['00']);
          cell00.colSpan = 2;
          row0.appendChild(cell00);
          table.appendChild(row0);
          for (let i = 0; i < 12; i++) {
            let row = document.createElement('tr');
            for (let j = 0; j < 3; j++) {
              let num = (i * 3 + j + 1).toString();
              let cell = document.createElement('td');
              cell.textContent = num;
              cell.className = 'heatmap-cell';
              cell.style.backgroundColor = getColorForCount(frequencies[num]);
              row.appendChild(cell);
            }
            table.appendChild(row);
          }
        }
        heatmapDisplayDiv.appendChild(table);
      } else {
        let racetrackDiv = document.createElement('div');
        racetrackDiv.style.display = 'flex';
        racetrackDiv.style.flexWrap = 'wrap';
        racetrackDiv.style.justifyContent = 'center';
        let wheelOrder = [];
        if (tableType === 'european') {
          wheelOrder = ['0', '32', '15', '19', '4', '21', '2', '25', '17', '34', '6', '27', '13', '36', '11', '30', '8', '23', '10', '5', '24', '16', '33', '1', '20', '14', '31', '9', '22', '18', '29', '7', '28', '12', '35', '3', '26'];
        } else {
          wheelOrder = ['0', '28', '9', '26', '30', '11', '7', '20', '32', '17', '5', '22', '34', '15', '3', '24', '36', '13', '1', '00', '27', '10', '25', '29', '12', '8', '19', '31', '18', '6', '21', '4', '2', '23', '35', '14', '16'];
        }
        wheelOrder.forEach(num => {
          let box = document.createElement('div');
          box.textContent = num;
          box.style.width = '40px';
          box.style.height = '40px';
          box.style.display = 'flex';
          box.style.justifyContent = 'center';
          box.style.alignItems = 'center';
          box.style.margin = '2px';
          box.style.border = '1px solid #000';
          box.style.borderRadius = '4px';
          box.style.backgroundColor = getColorForCount(frequencies[num] || 0);
          racetrackDiv.appendChild(box);
        });
        heatmapDisplayDiv.appendChild(racetrackDiv);
      }
    }

    // --- Reset Functionality ---
    resetButton.addEventListener('click', function() {
      selectedNumbers = [];
      updateSelectedNumbersDisplay();
      if (selectedNumbers.length < minSpinsForHeatmap) {
        heatmapOptionsDiv.classList.add('hidden');
      }
      const buttons = numberGridDiv.getElementsByClassName('roulette-button');
      for (let btn of buttons) {
        btn.dataset.count = 0;
        btn.textContent = btn.dataset.number;
      }
      heatmapDisplayDiv.innerHTML = '';
      heatmapDisplayDiv.classList.add('hidden');
      currentHeatmapLayout = null;
      updateLineCounters();
      updateColumnCounters();
      // Reset bet suggestion and consecutive losses
      currentBet.betType = null;
      currentBet.betTarget = null;
      currentBet.betSize = 0;
      consecutiveLosses = 0;
      displayBankroll();
      updateBetSuggestion(true);
      lastBetResultDisplay.textContent = 'N/A';
    });

    // --- Betting Progression Functions & Rounding ---
    function roundBetSize(value) {
      return Math.ceil(value / roundingFactor) * roundingFactor;
    }

    function getNextBetMartingale(losses, base) {
      return base * (2 ** losses);
    }

    function getNextBetFibonacci(losses, base) {
      // Fibonacci: fib(0)=1, fib(1)=1, fib(2)=2, etc.
      function fib(n) {
        if(n<=1)return 1;
        let a=1, b=1;
        for(let i=2; i<=n; i++){
          let temp = a+b;
          a = b;
          b = temp;
        }
        return b;
      }
      return base * fib(losses);
    }

    function getNextBetPadovan(losses, base) {
      // Padovan: P(0)=1, P(1)=1, P(2)=1, P(n)=P(n-2)+P(n-3)
      function padovan(n) {
        if(n < 3) return 1;
        let p0 = 1, p1 = 1, p2 = 1;
        let p;
        for(let i=3; i<=n; i++){
          p = p0 + p1; // P(n)=P(n-3)+P(n-2)
          p0 = p1;
          p1 = p2;
          p2 = p;
        }
        return p;
      }
      return base * padovan(losses);
    }

    // --- Bet Suggestion Logic ---
    function checkLastBetResult(latestNumber) {
      if (!currentBet.betTarget || !currentBet.betType || currentBet.betSize === 0) return;
      let groupArray = currentBet.betType === 'line' ? lineGroups : columnGroups;
      let targetGroup = groupArray.find(g => g.name === currentBet.betTarget);
      if (!targetGroup) return;
      if (targetGroup.numbers.includes(latestNumber)) {
        lastBetResultDisplay.textContent = 'WIN';
        // Win: add winnings and reset consecutive losses
        let multiplier = (currentBet.betType === 'line') ? 5 : 2;
        let winAmount = currentBet.betSize * multiplier;
        bankroll += winAmount;
        consecutiveLosses = 0;
      } else {
        lastBetResultDisplay.textContent = 'LOSS';
        bankroll -= currentBet.betSize;
        consecutiveLosses++;
      }
      displayBankroll();
    }

    function updateBetSuggestion(resetToNA = false) {
      if (resetToNA) {
        suggestedBetDisplay.textContent = 'N/A';
        betSizeDisplay.textContent = 'N/A';
        winProbabilityDisplay.textContent = 'N/A';
        return;
      }
      if (selectedNumbers.length < 5) {
        suggestedBetDisplay.textContent = 'Not enough spins yet...';
        betSizeDisplay.textContent = 'N/A';
        winProbabilityDisplay.textContent = 'N/A';
        return;
      }
      // Pick the group with the highest gap (from lines and columns)
      let bestLine = getMaxGapGroup(lineGroups);
      let bestColumn = getMaxGapGroup(columnGroups);
      if (bestLine.gap >= bestColumn.gap) {
        currentBet.betType = 'line';
        currentBet.betTarget = bestLine.name;
      } else {
        currentBet.betType = 'column';
        currentBet.betTarget = bestColumn.name;
      }
      // Calculate next bet size using chosen progression:
      let baseStake = 0;
      if (stakeStyle === 'fixed') {
        baseStake = baseBet;
      } else {
        baseStake = Math.floor((bankroll * basePercent) / 100);
        if (baseStake < 1) baseStake = 1;
      }
      let nextBet = 0;
      if (consecutiveLosses === 0) {
        nextBet = baseStake;
      } else {
        if (betProgression === 'martingale') {
          nextBet = getNextBetMartingale(consecutiveLosses, baseStake);
        } else if (betProgression === 'fibonacci') {
          nextBet = getNextBetFibonacci(consecutiveLosses, baseStake);
        } else if (betProgression === 'padovan') {
          nextBet = getNextBetPadovan(consecutiveLosses, baseStake);
        }
      }
      nextBet = roundBetSize(nextBet);
      currentBet.betSize = nextBet;
      suggestedBetDisplay.textContent = `${currentBet.betTarget} (${currentBet.betType})`;
      betSizeDisplay.textContent = currentBet.betSize.toString();

      // Calculate win probability based on base probability and gap:
      let baseProbability = 0;
      if (tableType === 'european') {
        baseProbability = (currentBet.betType === 'line') ? (6/37) : (12/37);
      } else {
        baseProbability = (currentBet.betType === 'line') ? (6/38) : (12/38);
      }
      // Get gap for the chosen group:
      let gap = getGroupGap(currentBet.betType === 'line' ? lineGroups : columnGroups, currentBet.betTarget);
      let winProbability = 1 - Math.pow((1 - baseProbability), (gap + 1));
      winProbabilityDisplay.textContent = (winProbability * 100).toFixed(1) + '%';
    }

    function getMaxGapGroup(groupArray) {
      let bestGroup = { name: '', gap: -1 };
      for (let group of groupArray) {
        let gap = getGroupGap(groupArray, group.name);
        if (gap > bestGroup.gap) {
          bestGroup.name = group.name;
          bestGroup.gap = gap;
        }
      }
      return bestGroup;
    }

    function getGroupGap(groupArray, targetName) {
      let group = groupArray.find(g => g.name === targetName);
      if (!group) return 0;
      let lastIndex = -1;
      for (let i = selectedNumbers.length - 1; i >= 0; i--) {
        if (group.numbers.includes(selectedNumbers[i])) {
          lastIndex = i;
          break;
        }
      }
      return (lastIndex === -1) ? selectedNumbers.length : (selectedNumbers.length - lastIndex - 1);
    }

    function displayBankroll() {
      bankrollDisplay.textContent = bankroll.toString();
    }
  </script>
</body>
</html>
